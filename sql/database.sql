create table databasechangelog
(
    id            varchar(255) not null,
    author        varchar(255) not null,
    filename      varchar(255) not null,
    dateexecuted  timestamp    not null,
    orderexecuted integer      not null,
    exectype      varchar(10)  not null,
    md5sum        varchar(35),
    description   varchar(255),
    comments      varchar(255),
    tag           varchar(255),
    liquibase     varchar(20),
    contexts      varchar(255),
    labels        varchar(255),
    deployment_id varchar(10)
);

alter table databasechangelog
    owner to postgres;

create table databasechangeloglock
(
    id          integer not null
        primary key,
    locked      boolean not null,
    lockgranted timestamp,
    lockedby    varchar(255)
);

alter table databasechangeloglock
    owner to postgres;

create table useraccount
(
    user_id     bigint generated by default as identity
        primary key,
    keycloak_id varchar(100) not null
);

alter table useraccount
    owner to postgres;

create table customer
(
    customer_id     bigint generated by default as identity
        primary key,
    user_id         bigint                      not null,
    first_name      varchar(50)                 not null,
    last_name       varchar(50)                 not null,
    account_balance numeric(10, 2) default 0.00 not null
);

alter table customer
    owner to postgres;

create table staffmember
(
    staff_id   bigint generated by default as identity
        primary key,
    user_id    bigint                      not null,
    first_name varchar(50)                 not null,
    last_name  varchar(50)                 not null,
    salary     numeric(10, 2) default 0.00 not null,
    job_title  varchar(100)                not null,
    hire_date  date                        not null
);

alter table staffmember
    owner to postgres;

create table address
(
    address_id     bigint generated by default as identity
        primary key,
    user_id        bigint                not null,
    address_type   varchar(20)           not null
        constraint address_address_type_check
            check ((address_type)::text = ANY
                   (ARRAY [('DELIVERY'::character varying)::text, ('PAYMENT'::character varying)::text, ('STAFF'::character varying)::text, ('WAREHOUSE'::character varying)::text, ('SUPPLIER'::character varying)::text])),
    street_address varchar(100)          not null,
    city           varchar(50)           not null,
    state          varchar(50)           not null,
    postal_code    varchar(20)           not null,
    country        varchar(50)           not null,
    is_default     boolean default false not null
);

alter table address
    owner to postgres;

create table creditcard
(
    card_id            bigint generated by default as identity
        primary key,
    customer_id        bigint                not null,
    card_number        varchar(19)           not null,
    cardholder_name    varchar(100)          not null,
    expiration_date    date                  not null,
    cvv                varchar(4)            not null,
    payment_address_id bigint                not null,
    is_default         boolean default false not null
);

alter table creditcard
    owner to postgres;

create table productcategory
(
    category_id   bigint generated by default as identity
        primary key,
    category_name varchar(50) not null,
    description   text        not null
);

alter table productcategory
    owner to postgres;

create table product
(
    product_id    bigint generated by default as identity
        primary key,
    category_id   bigint                       not null,
    name          varchar(100)                 not null,
    brand         varchar(50)                  not null,
    description   text                         not null,
    size          varchar(20)                  not null,
    weight        numeric(10, 2)               not null,
    current_price numeric(10, 2) default 0.00  not null,
    image_url     varchar(255)                 not null,
    creation_date timestamp      default now() not null,
    last_updated  timestamp      default now() not null,
    product_type  varchar(50)                  not null
);

alter table product
    owner to postgres;

create table warehouse
(
    warehouse_id   bigint generated by default as identity
        primary key,
    warehouse_name varchar(100)   not null,
    address_id     bigint         not null,
    capacity       numeric(10, 2) not null
);

alter table warehouse
    owner to postgres;

create table stock
(
    stock_id       bigint generated by default as identity
        primary key,
    product_id     bigint                       not null,
    warehouse_id   bigint                       not null,
    quantity       integer                      not null,
    unit_size      numeric(10, 2) default 1.0   not null,
    last_restocked timestamp      default now() not null
);

alter table stock
    owner to postgres;

create table customerorder
(
    order_id     bigint generated by default as identity
        primary key,
    customer_id  bigint                       not null,
    order_date   timestamp      default now() not null,
    status       varchar(20)                  not null
        constraint customerorder_status_check
            check ((status)::text = ANY
                   (ARRAY [('ISSUED'::character varying)::text, ('SENT'::character varying)::text, ('RECEIVED'::character varying)::text, ('CANCELLED'::character varying)::text])),
    card_id      bigint                       not null,
    total_amount numeric(10, 2) default 0.00  not null
);

alter table customerorder
    owner to postgres;

create table deliveryplan
(
    delivery_id         bigint generated by default as identity
        primary key,
    order_id            bigint                      not null,
    delivery_type       varchar(20)                 not null
        constraint deliveryplan_delivery_type_check
            check ((delivery_type)::text = ANY
                   (ARRAY [('STANDARD'::character varying)::text, ('EXPRESS'::character varying)::text])),
    delivery_price      numeric(10, 2) default 0.00 not null,
    ship_date           date                        not null,
    delivery_date       date                        not null,
    delivery_address_id bigint                      not null
);

alter table deliveryplan
    owner to postgres;

create table orderitem
(
    order_item_id     bigint generated by default as identity
        primary key,
    order_id          bigint                      not null,
    product_id        bigint                      not null,
    quantity          integer                     not null,
    price_at_purchase numeric(10, 2) default 0.00 not null
);

alter table orderitem
    owner to postgres;

create table supplier
(
    supplier_id   bigint generated by default as identity
        primary key,
    supplier_name varchar(100) not null,
    address_id    bigint       not null,
    contact_name  varchar(100) not null,
    contact_email varchar(100) not null,
    contact_phone varchar(20)  not null
);

alter table supplier
    owner to postgres;

create table supplierproduct
(
    supplier_product_id    bigint generated by default as identity
        primary key,
    supplier_id            bigint                      not null,
    product_id             bigint                      not null,
    supplier_price         numeric(10, 2) default 0.00 not null,
    minimum_order_quantity integer        default 1    not null,
    lead_time_days         integer
);

alter table supplierproduct
    owner to postgres;

create function check_warehouse_capacity() returns trigger
    language plpgsql
as
$$
DECLARE
    total_used_capacity DECIMAL(10, 2);
    warehouse_max_capacity
                        DECIMAL(10, 2);
BEGIN -- Get the warehouse capacity
    SELECT capacity
    INTO warehouse_max_capacity
    FROM Warehouse
    WHERE warehouse_id = NEW.warehouse_id;
-- Calculate total used capacity (including the new stock)
    SELECT COALESCE(SUM(s.quantity * s.unit_size), 0)
    INTO total_used_capacity
    FROM Stock s
    WHERE s.warehouse_id = NEW.warehouse_id
      AND s.product_id != NEW.product_id;
-- Add the new stock's capacity
    total_used_capacity
        := total_used_capacity + (NEW.quantity * NEW.unit_size);
-- Check if warehouse has enough capacity
    IF
        total_used_capacity > warehouse_max_capacity THEN
        RAISE EXCEPTION 'Warehouse capacity exceeded. Available: %, Required: %',
            warehouse_max_capacity,
            total_used_capacity;
    END IF;
    RETURN NEW;
END;
$$;

alter function check_warehouse_capacity() owner to postgres;

create trigger enforce_warehouse_capacity
    before insert or update
    on stock
    for each row
execute procedure check_warehouse_capacity();

create function update_product_timestamp() returns trigger
    language plpgsql
as
$$
BEGIN
    NEW.last_updated := CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$;

alter function update_product_timestamp() owner to postgres;

create trigger product_timestamp_update
    before update
    on product
    for each row
execute procedure update_product_timestamp();

create function check_product_availability() returns trigger
    language plpgsql
as
$$
DECLARE
    available_quantity INT;
    product_name
                       VARCHAR(100);
BEGIN -- Get total available quantity across all warehouses
    SELECT COALESCE(SUM(quantity), 0)
    INTO available_quantity
    FROM Stock
    WHERE product_id = NEW.product_id;
-- Get product name for error message
    SELECT name
    INTO product_name
    FROM Product
    WHERE product_id = NEW.product_id;
-- Check if enough product is available
    IF
        available_quantity < NEW.quantity THEN
        RAISE EXCEPTION 'Insufficient stock for product "%". Available: %, Requested: %',
            product_name,
            available_quantity,
            NEW.quantity;
    END IF;
    RETURN NEW;
END;
$$;

alter function check_product_availability() owner to postgres;

create trigger enforce_product_availability
    before insert
    on orderitem
    for each row
execute procedure check_product_availability();

create function update_customer_balance() returns trigger
    language plpgsql
as
$$
BEGIN -- Add the order total to the customer's balance
    UPDATE Customer
    SET account_balance = account_balance + NEW.total_amount
    WHERE customer_id = NEW.customer_id;
    RETURN NEW;
END;
$$;

alter function update_customer_balance() owner to postgres;

create trigger customer_balance_update
    after insert
    on customerorder
    for each row
execute procedure update_customer_balance();

create function update_stock_after_order() returns trigger
    language plpgsql
as
$$
DECLARE
    remaining_quantity INT;
    warehouse_cursor
        CURSOR FOR
        SELECT warehouse_id,
               quantity
        FROM Stock
        WHERE product_id = NEW.product_id
        ORDER BY quantity DESC;
-- Take from warehouses with most stock first
    warehouse_record
                       RECORD;
BEGIN
    remaining_quantity
        := NEW.quantity;
-- Iterate through warehouses to deduct stock
    OPEN warehouse_cursor;
    LOOP
        FETCH warehouse_cursor INTO warehouse_record;
        EXIT
            WHEN NOT FOUND
                OR remaining_quantity <= 0;
        IF
            warehouse_record.quantity >= remaining_quantity THEN -- Enough stock in this warehouse
            UPDATE Stock
            SET quantity = quantity - remaining_quantity
            WHERE warehouse_id = warehouse_record.warehouse_id
              AND product_id = NEW.product_id;
            remaining_quantity
                := 0;
        ELSE -- Take all available from this warehouse and continue to next
            UPDATE Stock
            SET quantity = 0
            WHERE warehouse_id = warehouse_record.warehouse_id
              AND product_id = NEW.product_id;
            remaining_quantity
                := remaining_quantity - warehouse_record.quantity;
        END IF;
    END LOOP;
    CLOSE warehouse_cursor;
    RETURN NEW;
END;
$$;

alter function update_stock_after_order() owner to postgres;

create trigger stock_update_after_order
    after insert
    on orderitem
    for each row
execute procedure update_stock_after_order();


